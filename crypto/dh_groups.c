#include <xinu.h>

/* DH group 1 */
#define MAGIC_WORD 0x12345678

uint16 P_1val[] = {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x5381, 0xECE6, 0x6651, 0x4928, 0x1FE6, 0x7C4B, 0x2411, 0xAE9F, 0x9FA5, 0x5A89, 0x6BFB, 0xEE38, 0xB7ED, 0xF406, 0x5CB6, 0x0BFF, 0xED6B, 0xA637, 0x42E9, 0xF44C, 0x7EC6, 0x625E, 0xB576, 0xE485, 0xC245, 0x6D51, 0x356D, 0x4FE1, 0x1437, 0xF25F, 0x0A6D, 0x302B, 0x431B, 0xCD3A, 0x19B3, 0xEF95, 0x04DD, 0x8E34, 0x0879, 0x514A, 0x9B22, 0x3B13, 0xBEA6, 0x020B, 0xCC74, 0x8A67, 0x4E08, 0x2902, 0x1CD1, 0x80DC, 0x628B, 0xC4C6, 0xC234, 0x2168,0xDAA2, 0xC90F, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000};
MPINT P_1 = {.val = P_1val, .order = 64, .size = 65, .sign = 1};

// R2P_1 = (2^1024)^2 mod P_1
uint16 R2P_1val[] = { 0x1f42, 0x6003, 0xf055, 0x86b8, 0xe3b2, 0xc7b5, 0x1890, 0xc52e, 0x172a, 0x1893, 0x7232, 0x7cae, 0x89e3, 0x9699, 0x58a4, 0x55da, 0x09b5, 0x267f, 0xfbfa, 0x1f69, 0x0803, 0x01b8, 0x5d0d, 0x64e9, 0x1c6d, 0x00c5, 0x5e84, 0x0d95, 0x37f2, 0x63e6, 0xaea8, 0xa513, 0x158c, 0x74ce, 0x1526, 0x0cb0, 0x5e02, 0xeb65, 0x91e4, 0xe127, 0x41c7, 0x3100, 0xd1e7, 0x0092, 0x80c2, 0xc388, 0x8fec, 0x010d, 0x648d, 0xa6b7, 0xe34c, 0xb990, 0x16fb, 0xe986, 0x67cc, 0x4325, 0x698d, 0x5a74, 0x28c7, 0x0345, 0x3ead, 0x3c30, 0xc282, 0x6415, 0x0000};
MPINT R2P_1 = {.val = R2P_1val, .order = 64, .size = 65, .sign = 1};

// INVP_1 = -(P_1)^(-1) mod 2^1024
uint16 INVP_1val[] = {0x0001, 0x0000, 0x0000, 0x0000, 0x5382, 0xece6, 0x6651, 0x4928, 0xadea, 0x5520, 0x0d87, 0x3ac5, 0x59df, 0x2b7d, 0xbf9d, 0x240e, 0x3465, 0xcf12, 0x8201, 0xbe54, 0x47cd, 0x5c7f, 0x20ec, 0xe6fd, 0x2f8d, 0xa448, 0xd49d, 0xbf28, 0x6aba, 0x23b3, 0xb2d8, 0x4c32, 0x0c37, 0x45b0, 0x6eb3, 0x17f2, 0xe43c, 0x8112, 0x7b1d, 0x80f6, 0xa3a4, 0x1c49, 0x90fd, 0x57e4, 0xba70, 0xfd07, 0xba88, 0x4396, 0x9853, 0xd1f2, 0xe82c, 0xe792, 0x3c1f, 0x1a26, 0x9b3e, 0x5fc4, 0xfb98, 0x1084, 0xa0bd, 0x33c2, 0xbef2, 0xaf01, 0xf0e0, 0xc486, 0x0000};
MPINT INVP_1 = {.val = INVP_1val, .order = 64, .size = 65, .sign = 1};

// Q_1 = (P_1 - 1) / 2
uint16 Q_1val[] = {0xffff, 0xffff, 0xffff, 0xffff, 0x29c0, 0xf673, 0x3328, 0x2494, 0x8ff3, 0xbe25, 0x9208, 0xd74f, 0xcfd2, 0xad44, 0x35fd, 0xf71c, 0x5bf6, 0x7a03, 0xae5b, 0x85ff, 0xf6b5, 0xd31b, 0x2174, 0x7a26, 0x3f63, 0x312f, 0xdabb, 0xf242, 0xe122, 0xb6a8, 0x9ab6, 0xa7f0, 0x8a1b, 0xf92f, 0x8536, 0x9815, 0x218d, 0xe69d, 0x8cd9, 0xf7ca, 0x026e, 0xc71a, 0x043c, 0x28a5, 0xcd91, 0x1d89, 0xdf53, 0x0105, 0xe63a, 0x4533, 0x2704, 0x9481, 0x0e68, 0xc06e, 0x3145, 0x6263, 0x611a, 0x10b4, 0xed51, 0xe487, 0xffff, 0xffff, 0xffff, 0x7fff, 0x0000};
MPINT Q_1 = {.val = Q_1val, .order = 64, .size = 65, .sign = 1};


MPPRIME PP_1 = {.num = {.val = P_1val, .order = 64, .size = 65, .sign = 1},
	.inv = {.val = INVP_1val, .order = 64, .size = 65, .sign = 1},
	.r_square = {.val = R2P_1val, .order = 64, .size = 65, .sign = 1}};
DH_GROUPMP DH_G1 = {
	.p = {
		.num = {.val = P_1val, .order = 64, .size = 65, .sign = 1},
		.inv = {.val = INVP_1val, .order = 64, .size = 65, .sign = 1},
		.r_square = {.val = R2P_1val, .order = 64, .size = 65, .sign = 1}},
	.generator = 2,
	.order =  {.val = Q_1val, .order = 64, .size = 65, .sign = 1},
	.size = 64};

/* DH group 14 */

uint16 P_14val[] = {0xffff, 0xffff, 0xffff, 0xffff, 0xaa68, 0x8aac, 0x8e5a, 0x1572, 0x0510, 0x98fa, 0x2618, 0x15d2, 0x6ae5, 0xea95, 0x497c, 0x3995, 0x1718, 0x9558, 0xcbf6, 0xde2b, 0x52c9, 0x6f4c, 0x5df0, 0xb5c5, 0xa28f, 0xec07, 0x83a2, 0x9b27, 0x8603, 0x180e, 0x772c, 0xe39e, 0xce3b, 0x2e36, 0x5e46, 0x3290, 0x217c, 0xca18, 0x6c08, 0xf174, 0x9804, 0x4abc, 0x354e, 0x670c, 0x966d, 0x7096, 0x2907, 0x9ed5, 0x52bb, 0x2085, 0xf356, 0x1c62, 0xad96, 0xdca3, 0x5d23, 0x8365, 0xcf5f, 0xfd24, 0x3fa8, 0x6916, 0xd39a, 0x1c55, 0x4836, 0x98da, 0xbf05, 0xa163, 0x7cb8, 0xc200, 0x5b3d, 0xece4, 0x6651, 0x4928, 0x1fe6, 0x7c4b, 0x2411, 0xae9f, 0x9fa5, 0x5a89, 0x6bfb, 0xee38, 0xb7ed, 0xf406, 0x5cb6, 0x0bff, 0xed6b, 0xa637, 0x42e9, 0xf44c, 0x7ec6, 0x625e, 0xb576, 0xe485, 0xc245, 0x6d51, 0x356d, 0x4fe1, 0x1437, 0xf25f, 0x0a6d, 0x302b, 0x431b, 0xcd3a, 0x19b3, 0xef95, 0x04dd, 0x8e34, 0x0879, 0x514a, 0x9b22, 0x3b13, 0xbea6, 0x020b, 0xcc74, 0x8a67, 0x4e08, 0x2902, 0x1cd1, 0x80dc, 0x628b, 0xc4c6, 0xc234, 0x2168, 0xdaa2, 0xc90f, 0xffff, 0xffff, 0xffff, 0xffff, 0x0000};
MPINT P_14 = {.val = P_14val, .order = 128, .size = 129, .sign = 1};

// R2P_14 = (2^2048)^2 mod P_14
uint16 R2P_14val[] = {0xb664, 0x125f, 0x22ce, 0x4771, 0xd313, 0x9b38, 0x48fb, 0xb035, 0x12c1, 0x6fd4, 0x53ff, 0x4c21, 0x9bc6, 0x873f, 0x2b50, 0x2a09, 0xf5f9, 0xfcb7, 0x1629, 0xbbc7, 0x84e7, 0x36bd, 0x06e1, 0x4bec, 0x0cb1, 0x6b02, 0x725a, 0x27ba, 0x9eeb, 0xed93, 0x5426, 0xf811, 0x30d9, 0x8a0e, 0xb187, 0x4bc1, 0x33ff, 0x2586, 0x820e, 0x5620, 0x3071, 0x785a, 0xd6ab, 0x074e, 0xcb61, 0x81f1, 0x105f, 0xf228, 0x6f7f, 0x4e2e, 0x436f, 0x570e, 0x0bd9, 0xd745, 0x2ff7, 0x5ca5, 0x0a7e, 0x75f1, 0x72d2, 0x5522, 0x7978, 0x739c, 0x7925, 0xac2b, 0x54d0, 0x325b, 0x8257, 0xa2f8, 0x2bd5, 0xe8d7, 0x1c9d, 0xbc82, 0x2986, 0x866d, 0x42b3, 0xdbd4, 0xb2ce, 0x70c4, 0x951b, 0x9478, 0x0c76, 0x9491, 0x8fb3, 0x5d99, 0x0867, 0x7e30, 0xb293, 0xf273, 0x9f92, 0x3856, 0x6bbe, 0x8c10, 0x92c5, 0x14e9, 0x92cb, 0xf83c, 0x80dd, 0xed68, 0x6e7e, 0xd85d, 0xa1df, 0xbe06, 0x276f, 0xeb5b, 0xe105, 0xfa11, 0x2090, 0x2a49, 0x00be, 0x19ea, 0xd96d, 0x63bd, 0x98ab, 0x0a16, 0x8297, 0x2723, 0xc974, 0x9240, 0x686c, 0x8a3a, 0x3000, 0x6661, 0x5703, 0x3ed8, 0x3197, 0x628b, 0x7a33, 0x0cd3, 0x0000};
MPINT R2P_14 = {.val = R2P_14val, .order = 128, .size = 129, .sign = 1};

// INVP_14 = -(P_14)^(-1) mod 2^2048
uint16 INVP_14val[] = {0x0001, 0x0000, 0x0000, 0x0000, 0xaa69, 0x8aac, 0x8e5a, 0x1572, 0xa421, 0x3b81, 0x101b, 0x6ee9, 0xc198, 0x3920, 0x03fb, 0x01ab, 0x42d0, 0xc86b, 0x2fe9, 0xf1dc, 0xdcbd, 0xe13d, 0x0deb, 0x9997, 0x18e6, 0xefb2, 0xb769, 0x6878, 0x1e72, 0x1fdf, 0x6d29, 0x7e03, 0xc8f0, 0x81f4, 0xb585, 0x6d24, 0xe491, 0x2d69, 0xf6cf, 0x14a6, 0xdaed, 0xd3b6, 0x2303, 0xf0e2, 0x9335, 0xa2e3, 0x133b, 0xf907, 0xffa4, 0xadd6, 0xc062, 0x831e, 0xc832, 0x1352, 0xd657, 0xf6e9, 0xb9c8, 0x809e, 0x3ec4, 0x3da1, 0x7033, 0x7af2, 0xd0b2, 0x917d, 0xaea6, 0xea45, 0xc91d, 0xf5ac, 0xe333, 0x4b44, 0x1304, 0x15d8, 0xacc8, 0x7fdb, 0x2632, 0xa190, 0x2f66, 0xf805, 0xa761, 0x5d52, 0x2f03, 0xa7b3, 0x033b, 0x0697, 0xdd69, 0x3ebc, 0xf477, 0x507d, 0x607a, 0x5df8, 0x6597, 0x23b9, 0x37c0, 0x4e01, 0x4926, 0x46ce, 0xf178, 0x6bd1, 0x561b, 0x3d32, 0x004e, 0x4bf1, 0xa3da, 0x8f56, 0x5bd7, 0xb1e7, 0xdaff, 0xeab8, 0x872a, 0x4160, 0xee9e, 0x70db, 0xfbde, 0x2c22, 0xe543, 0x0843, 0xf91c, 0x159c, 0x97d8, 0xd576, 0x8203, 0x8b9e, 0xa756, 0x63e1, 0xc411, 0xf5b8, 0x005f, 0xf1d8, 0x0000};
MPINT INVP_14 = {.val = INVP_14val, .order = 64, .size = 65, .sign = 1};

// Q_14 = (P_14 - 1) / 2
uint16 Q_14val[] = {0xffff, 0xffff, 0xffff, 0x7fff, 0x5534, 0x4556, 0x472d, 0x0ab9, 0x0288, 0x4c7d, 0x130c, 0x8ae9, 0xb572, 0x754a, 0xa4be, 0x1cca, 0x0b8c, 0x4aac, 0xe5fb, 0xef15, 0x2964, 0x37a6, 0xaef8, 0xdae2, 0xd147, 0x7603, 0xc1d1, 0xcd93, 0x4301, 0x0c07, 0x3b96, 0xf1cf, 0x671d, 0x171b, 0x2f23, 0x1948, 0x10be, 0x650c, 0x3604, 0x78ba, 0x4c02, 0x255e, 0x1aa7, 0xb386, 0x4b36, 0xb84b, 0x9483, 0xcf6a, 0xa95d, 0x1042, 0x79ab, 0x0e31, 0xd6cb, 0xee51, 0xae91, 0xc1b2, 0x67af, 0x7e92, 0x1fd4, 0x348b, 0xe9cd, 0x0e2a, 0x241b, 0xcc6d, 0xdf82, 0x50b1, 0x3e5c, 0xe100, 0x2d9e, 0xf672, 0x3328, 0x2494, 0x8ff3, 0xbe25, 0x9208, 0xd74f, 0xcfd2, 0xad44, 0x35fd, 0xf71c, 0x5bf6, 0x7a03, 0xae5b, 0x85ff, 0xf6b5, 0xd31b, 0x2174, 0x7a26, 0x3f63, 0x312f, 0xdabb, 0xf242, 0xe122, 0xb6a8, 0x9ab6, 0xa7f0, 0x8a1b, 0xf92f, 0x8536, 0x9815, 0x218d, 0xe69d, 0x8cd9, 0xf7ca, 0x026e, 0xc71a, 0x043c, 0x28a5, 0xcd91, 0x1d89, 0xdf53, 0x0105, 0xe63a, 0x4533, 0x2704, 0x9481, 0x0e68, 0xc06e, 0x3145, 0x6263, 0x611a, 0x10b4, 0xed51, 0xe487, 0xffff, 0xffff, 0xffff, 0x7fff, 0x0000};
MPINT Q_14 = {.val = Q_14val, .order = 64, .size = 65, .sign = 1};

MPPRIME PP_14 = {.num = {.val = P_14val, .order = 128, .size = 129, .sign = 1},
	.inv = {.val = INVP_14val, .order = 128, .size = 129, .sign = 1},
	.r_square = {.val = R2P_14val, .order = 128, .size = 129, .sign = 1}};
DH_GROUPMP DH_G14 = {
	.p = {
		.num = {.val = P_14val, .order = 128, .size = 129, .sign = 1},
		.inv = {.val = INVP_14val, .order = 128, .size = 129, .sign = 1},
		.r_square = {.val = R2P_14val, .order = 128, .size = 129, .sign = 1}},
	.generator = 2,
	.order =  {.val = Q_14val, .order = 128, .size = 129, .sign = 1},
	.size = 128};

//bool8 write_prime(int32 file, MPPRIME* p) {
//    byte* buf;
//    bool8 st;
//    int32 size = 0;
//    int32 size_needed = ((p->num).size + (p->inv).size + (p->r_square).size) * sizeof(HALF_WORD) + 15;
//
//    buf = (byte *)getmem(size_needed);
//    size += ssh_write_mpint(buf, &(p->num));
//    size += ssh_write_mpint(buf + size, &(p->inv));
//    size += ssh_write_mpint(buf + size, &(p->r_square));
//
//    st = TRUE;
//    if (write(file, (char *)buf, size) != size) {
//        st = FALSE;
//    }
//
//    kprintf("Size %d, needed %d\n", size, size_needed);
//
//    freemem((char *)buf, size_needed);
//
//    return st;
//
//}
//
//int32 read_prime(byte* buf, MPPRIME* p) {
//
//    int32 size;
//
//    size = ssh_read_mpint(buf, &(p->num));
//    size += ssh_read_mpint(buf + size, &(p->inv));
//    size += ssh_read_mpint(buf + size, &(p->r_square));
//
//    return size;
//}
//
//void ssh_store_DH_group(DH_GROUPMP* group, char* name) {
//    int32 file;
//    int32 next;
//
//    char filename[128];
//
//    memset(filename, 0, sizeof(filename));
//    next = strcopy((byte *)filename, "dh_groups/");
//    strcopy((byte *)filename + next, name);
//
//    if ((file = open(RFILESYS, filename, "w")) == SYSERR) {
//        kprintf("Fail opening file\n");
//        return;
//    }
//
//    /* add magic word */
//    next = htonl(MAGIC_WORD);
//    if (write(file, (char *) &next, sizeof(next)) != sizeof(next)) {
//        kprintf("Fail writing MAGIC WORD\n");
//        close(file);
//        return;
//    }
//
//    /* write p */
//    if (write_prime(file, &(group->p)) == FALSE) {
//        kprintf("Fail writing P\n");
//        close(file);
//    }
//
//    /* write g */
//    next = htonl(group->generator);
//    if (write(file, (char *) &next, sizeof(next)) != sizeof(next)) {
//        kprintf("Fail writing generator\n");
//        close(file);
//        return;
//    }
//
//    /* write order */
//    if (write_prime(file, &(group->order)) == FALSE) {
//        kprintf("Fail writing order\n");
//        close(file);
//    }
//
//    /* write size */
//    next = htonl(group->size);
//    if (write(file, (char *) &next, sizeof(next)) != sizeof(next)) {
//        kprintf("Fail writing size\n");
//        close(file);
//        return;
//    }
//
//    close(file);
//    kprintf("Done\n");
//}
//
//void ssh_read_DH_group(DH_GROUPMP* group, char* name) {
//    int32 file, fsize;
//    int32 next;
//    byte* fptr;
//    int32 nbytes;
//
//    char filename[128];
//
//    memset(filename, 0, sizeof(filename));
//    next = strcopy((byte *)filename, "dh_groups/");
//    strcopy((byte *)filename + next, name);
//
//    if ((file = open(RFILESYS, filename, "or")) == SYSERR) {
//        kprintf("Fail opening file\n");
//        return;
//    }
//
//    /* read complete file */
//    fsize = control(RFILESYS, RFS_CTL_SIZE, file, 0);
//    fptr = (byte *)getmem(fsize);
//    next = read(file, (char *)fptr, fsize);
//    close(file);
//
//    if (next == SYSERR || ntohl(*((uint32 *) fptr)) != MAGIC_WORD) {
//        kprintf("Incorrect file format\n");
//        freemem((char *)fptr, fsize);
//        return;
//    }
//    nbytes = sizeof(MAGIC_WORD);
//
//    /* write p */
//    init_mpprime(&(group->p));
//    nbytes += read_prime(fptr + nbytes, &(group->p));
//    if (nbytes > next) {
//        kprintf("Fail reading P\n");
//        freemem((char *)fptr, fsize);
//        return;
//    }
//
//    /* write g */
//    group->generator = ntohl(*((int32 *) (fptr + nbytes)));
//    nbytes += sizeof(group->generator);
//    if (nbytes > next) {
//        kprintf("Fail reading generator\n");
//        freemem((char *)fptr, fsize);
//        return;
//    }
//
//    /* write order */
//    init_mpprime(&(group->order));
//    nbytes += read_prime(fptr + nbytes, &(group->order));
//    if (nbytes > next) {
//        kprintf("Fail reading order\n");
//        freemem((char *)fptr, fsize);
//        return;
//    }
//
//    /* write size */
//    /* write g */
//    group->size = ntohl(*((int32 *) (fptr + nbytes)));
//    nbytes += sizeof(group->size);
//    if (nbytes != next) {
//        kprintf("incorrect file length\n");
//        return;
//    }
//    kprintf("Done\n");
//}
